import { DatabaseConnector } from '../../../../../../contexts/shared/domain/contracts/database-connector';
import { Pool } from 'pg';
import { MalwareEvolutionRepository } from '../../../../../../contexts/malware-evolution/domain/contracts/malware-evolution.repository';
import { postgresqlMalwareEvolutionRepositoryBuilder } from '../../../../../../contexts/malware-evolution/infrastructure/database/postgresql/postgresql-malware-evolution.repository';
import { MalwareEvolutionPostgresDTO } from '../../../../../../contexts/malware-evolution/infrastructure/database/postgresql/postgresql-malware-evolution.mapper';
import { MalwareEvolutionBuilder } from '../../../__mocks__/malware-evolution.builder';
import { MalwareEvolution } from '../../../../../../contexts/malware-evolution/domain/models/malware-evolution.entity';

describe('PostgreSQL Malware evolution repository', () => {
  let queryMock: jest.Mock;
  let clientQueryMock: jest.Mock;
  let databaseConnectorMock: DatabaseConnector<Pool>;
  let postgresRepository: MalwareEvolutionRepository;

  let validResult: MalwareEvolution;
  let validDTO: MalwareEvolutionPostgresDTO;

  afterEach(() => {
    jest.clearAllMocks();
  });

  beforeAll(() => {
    queryMock = jest.fn().mockImplementation(() => ({ rows: [], rowCount: 0 }));
    clientQueryMock = jest.fn().mockImplementation(() => ({ rows: [], rowCount: 0 }));

    databaseConnectorMock = {
      async getConnection(): Promise<Pool> {
        return {
          query: queryMock,
          connect: jest.fn(() => ({
            query: clientQueryMock,
            release: jest.fn()
          }))
        } as unknown as Pool;
      }
    };

    postgresRepository = postgresqlMalwareEvolutionRepositoryBuilder({
      databaseConnector: databaseConnectorMock
    });

    validDTO = MalwareEvolutionBuilder().buildDto();
    validResult = MalwareEvolutionBuilder().build();
  });

  describe('findByWeek', () => {
    it('should return the malware evolution data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByWeek();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByWeek();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware evolution data grouped by week', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, month: undefined, country: undefined }],
        rowCount: 1
      });

      await postgresRepository.findByWeek();
      expect(queryMock).toHaveBeenCalledWith(
        'select num_week, year, count(*) as count from malware.malware_data_filtered GROUP BY num_week, year ORDER BY year asc, num_week asc',
        []
      );
    });
  });

  describe('findByMonth', () => {
    it('should return the malware evolution data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByMonth();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByWeek();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware evolution data grouped by month', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, num_week: undefined, country: undefined }],
        rowCount: 1
      });

      await postgresRepository.findByMonth();
      expect(queryMock).toHaveBeenCalledWith(
        'select month, year, count(*) from malware.malware_data_filtered GROUP BY month, year ORDER BY year asc, month asc',
        []
      );
    });
  });

  describe('findByCountry', () => {
    it('should return the malware evolution data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByCountry();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByWeek();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware evolution data grouped by country', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, month: undefined }],
        rowCount: 1
      });

      await postgresRepository.findByCountry();
      expect(queryMock).toHaveBeenCalledWith(
        'select num_week, year, country, count(*) from malware.malware_data_filtered GROUP BY num_week, year, country ORDER BY year asc, num_week asc, country asc',
        []
      );
    });
  });

  describe('findByMonthPeriod', () => {
    it('should return the malware evolution data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByMonthPeriod(2, 2021);
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByMonthPeriod(2, 2021);
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware evolution data by month', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, num_week: undefined, country: undefined }],
        rowCount: 1
      });

      const month = 2;
      const year = 2021;

      await postgresRepository.findByMonthPeriod(month, year);
      expect(queryMock).toHaveBeenCalledWith(
        'select month, count(*) from malware.malware_data_filtered WHERE year = $1 and month = $2 GROUP BY month',
        [year, month]
      );
    });
  });

  describe('findByYearPeriod', () => {
    it('should return the malware evolution data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByYearPeriod(2021);
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByYearPeriod(2021);
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware evolution data by year', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, num_week: undefined, country: undefined }],
        rowCount: 1
      });

      const year = 2021;

      await postgresRepository.findByYearPeriod(year);
      expect(queryMock).toHaveBeenCalledWith(
        'select year, count(*) from malware.malware_data_filtered WHERE year = $1 GROUP BY year',
        [year]
      );
    });
  });
});
