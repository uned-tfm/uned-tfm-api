import { mock } from 'jest-mock-extended';
import { MalwareEvolutionRepository } from '../../../../contexts/malware-evolution/domain/contracts/malware-evolution.repository';
import { UseCase } from '../../../../contexts/shared/application/use-case';
import { MalwareEvolution } from '../../../../contexts/malware-evolution/domain/models/malware-evolution.entity';
import { MalwareEvolutionBuilder } from '../__mocks__/malware-evolution.builder';
import {
  findByPeriodBuilder,
  FindByPeriodInput,
  PERIOD_TYPES
} from '../../../../contexts/malware-evolution/application/find-by-period.usecase';
import { FieldValidationError } from '../../../../contexts/shared/domain/errors';

describe('Find all malware evolution data usecase', () => {
  const mockMalwareEvolutionRepository = mock<MalwareEvolutionRepository>();

  let findByPeriod: UseCase<FindByPeriodInput, MalwareEvolution[]>;
  let validMalwareEvolutions: MalwareEvolution[];

  beforeAll(() => {
    validMalwareEvolutions = [MalwareEvolutionBuilder().build()];

    findByPeriod = findByPeriodBuilder({
      malwareEvolutionRepository: mockMalwareEvolutionRepository
    });
  });

  describe('input validation', () => {
    describe('when period type is ONE_MONTH', () => {
      it('should throw FieldValidationError when the year is invalid', async () => {
        await expect(
          findByPeriod({ type: PERIOD_TYPES.ONE_MONTH, year: null } as unknown as FindByPeriodInput)
        ).rejects.toThrow(FieldValidationError);
      });

      it('should throw FieldValidationError when the month is invalid', async () => {
        await expect(
          findByPeriod({
            type: PERIOD_TYPES.ONE_MONTH,
            year: 2023,
            month: null
          } as unknown as FindByPeriodInput)
        ).rejects.toThrow(FieldValidationError);
      });
    });

    describe('when period type is ONE_YEAR', () => {
      it('should throw FieldValidationError when the year is invalid', async () => {
        await expect(
          findByPeriod({ type: PERIOD_TYPES.ONE_YEAR, year: null } as unknown as FindByPeriodInput)
        ).rejects.toThrow(FieldValidationError);
      });
    });

    it('should throw FieldValidationError when the period type is invalid', async () => {
      await expect(
        findByPeriod({ type: 'invalid_type' } as unknown as FindByPeriodInput)
      ).rejects.toThrow(FieldValidationError);
    });
  });

  it('It should return malware evolution data by month period', async () => {
    mockMalwareEvolutionRepository.findByMonthPeriod.mockResolvedValue(validMalwareEvolutions);

    const result = await findByPeriod({ type: PERIOD_TYPES.ONE_MONTH, month: 2, year: 2021 });

    expect(mockMalwareEvolutionRepository.findByMonthPeriod).toBeCalled();
    expect(result).not.toBeNull();
    expect(result).toHaveLength(1);
  });

  it('It should return malware evolution data by year period', async () => {
    mockMalwareEvolutionRepository.findByYearPeriod.mockResolvedValue(validMalwareEvolutions);

    const result = await findByPeriod({ type: PERIOD_TYPES.ONE_YEAR, year: 2021 });

    expect(mockMalwareEvolutionRepository.findByYearPeriod).toBeCalled();
    expect(result).not.toBeNull();
    expect(result).toHaveLength(1);
  });
});
