import { DatabaseConnector } from '../../../../../../contexts/shared/domain/contracts/database-connector';
import { Pool } from 'pg';
import { MalwareTypeRepository } from '../../../../../../contexts/malware-types/domain/contracts/malware-type.repository';
import { MalwareType } from '../../../../../../contexts/malware-types/domain/models/malware-type.entity';
import { MalwareTypePostgresDTO } from '../../../../../../contexts/malware-types/infrastructure/database/postgresql/postgresql-malware-type.mapper';
import { postgresqlMalwareTypeRepositoryBuilder } from '../../../../../../contexts/malware-types/infrastructure/database/postgresql/postgresql-malware-type.repository';
import { MalwareTypeBuilder } from '../../../__mocks__/malware-type.builder';

describe('PostgreSQL File feature repository', () => {
  let queryMock: jest.Mock;
  let clientQueryMock: jest.Mock;
  let databaseConnectorMock: DatabaseConnector<Pool>;
  let postgresRepository: MalwareTypeRepository;

  let validResult: MalwareType;
  let validDTO: MalwareTypePostgresDTO;

  afterEach(() => {
    jest.clearAllMocks();
  });

  beforeAll(() => {
    queryMock = jest.fn().mockImplementation(() => ({ rows: [], rowCount: 0 }));
    clientQueryMock = jest.fn().mockImplementation(() => ({ rows: [], rowCount: 0 }));

    databaseConnectorMock = {
      async getConnection(): Promise<Pool> {
        return {
          query: queryMock,
          connect: jest.fn(() => ({
            query: clientQueryMock,
            release: jest.fn()
          }))
        } as unknown as Pool;
      }
    };

    postgresRepository = postgresqlMalwareTypeRepositoryBuilder({
      databaseConnector: databaseConnectorMock
    });

    validDTO = MalwareTypeBuilder().buildDto();
    validResult = MalwareTypeBuilder().build();
  });

  describe('findByCountry', () => {
    it('should return the malware type data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByCountry();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByCountry();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware type data grouped by country', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO }],
        rowCount: 1
      });

      await postgresRepository.findByCountry();
      expect(queryMock).toHaveBeenCalledWith(
        'select country, malware_type, count(*) as result from malware.malware_data_filtered GROUP BY country, malware_type ORDER BY country asc, count(*) desc',
        []
      );
    });
  });

  describe('findByMalwareType', () => {
    it('should return the malware type data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findByMalwareType();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findByMalwareType();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware type data grouped by malware type', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO, country: undefined }],
        rowCount: 1
      });

      await postgresRepository.findByMalwareType();
      expect(queryMock).toHaveBeenCalledWith(
        'select malware_type, count(*) as result from malware.malware_data_filtered GROUP BY malware_type ORDER BY count(*) desc',
        []
      );
    });
  });

  describe('findMoreNumDetections', () => {
    it('should return the file feature data', async () => {
      queryMock.mockReturnValueOnce({
        rows: [validDTO, validDTO],
        rowCount: 2
      });

      const result = await postgresRepository.findMoreNumDetections();
      expect(result).toHaveLength(2);
      expect(result[1]).toMatchObject(validResult);
    });

    it('should return the empty array', async () => {
      queryMock.mockReturnValueOnce({
        rows: [],
        rowCount: 0
      });

      const result = await postgresRepository.findMoreNumDetections();
      expect(result).toHaveLength(0);
      expect(result).toMatchObject([]);
    });

    it('should call the sql sentence that get the malware type data grouped by more uploads', async () => {
      queryMock.mockReturnValueOnce({
        rows: [{ ...validDTO }],
        rowCount: 1
      });

      await postgresRepository.findMoreNumDetections();
      expect(queryMock).toHaveBeenCalledWith(
        'select malware_type, sum(num_detections) as result from malware.malware_data_filtered GROUP BY malware_type ORDER BY sum(num_detections) desc',
        []
      );
    });
  });
});
